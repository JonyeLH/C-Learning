//#include <iostream>
//using namespace std;
//



//有问题
//class cstu
//{
//public:
//	int nage;
//	int *pp;
//	cstu()
//	{
//		cout << "构造函数" << endl;
//		pp = new int(10);
//	}
//
//	cstu(int i)
//	{
//		cout << "构造函数" << endl;
//	}
//
//
//	~cstu()			//析构函数形式不能重载，不能有参数，自动调用，作用域是主函数结束之前（return 0）或则有些是在 }花括号之前执行调用
//	{
//		cout << "析构函数" << endl;
//		delete pp;			//一般在析构函数地方释放空间
//	}
//};
//
//
//int main()
//{
//	//{
//	//	cstu stu;			 //在局部变量里，析构函数在花括号 } 前调用析构函数		
//	//}
//
//	//cstu stu;				//在主体函数里，析构函数是在return 0; 之前调用析构函数         //逐语句调试时有错
//
//
//
//	//cstu *stu = new cstu;	//析构函数在指针对象时，只有遇到delete释放空间时，才会调用析构函数      //逐语句调试时有错
//	//delete stu;
//
//
//
//	cstu(12);    //临时对象的构造    如 cstu tu(12) 就是构造了tu的临时对象					//逐语句调试时有错
//				 // 临时变量的作用域就是在当前语句中，语句将要结束时自动调用析构函数   
//				 // 也可以构造cstu() 这样无参的临时对象     所以构造临时对象时，要对应前面的构造函数的参数类型
//
//
//				 //int c = int(12);     类型+（参数）构造临时对象     如q=12  c=q  ：先构造一个q的临时变量，然后q对c进行赋值
//				 //int b = 12;		  直接给b赋值
//
//
//	system("pause");
//	return 0;
//}